using System.IdentityModel.Tokens.Jwt;
using System.Security.Claims;
using System.Text;
using Auth.Configuration;
using Auth.Data;
using Auth.Models;
using Auth.Models.DTOs;
using Microsoft.AspNetCore.Identity;
using Microsoft.EntityFrameworkCore;
using Microsoft.Extensions.Options;
using Microsoft.IdentityModel.Tokens;

namespace Auth.Service
{
    public interface ITokenService
    {
        Task<AuthResults> GenerateJwtToken(IdentityUser user);
        Task<AuthResults> ValidateAndGenerateToken(TokenRequestDto tokenRequest);
    }
    public class JwtTokenService(
        IOptions<JwtConfig> config,
        BlogDbContext context,
        TokenValidationParameters tokenValidationParameters,
        UserManager<IdentityUser> userManager
    ) : ITokenService
    {
        private readonly JwtConfig _config = config.Value;
        private readonly BlogDbContext _context = context;
        private readonly TokenValidationParameters _tokenValidationParameters = tokenValidationParameters;
        private readonly UserManager<IdentityUser> _userManager = userManager;

        public async Task<AuthResults> GenerateJwtToken(IdentityUser user)
        {
            var jwtTokenHandler = new JwtSecurityTokenHandler();

            // convert the string into byte of arrays
            var key = Encoding.UTF8.GetBytes(_config.Secret);
            /* Claims
                this is used to add key value pair of data that should be encrypetd 
                and addded to the jwt token
            */
            var _claims = new ClaimsIdentity([
                new Claim("Id",user.Id),
                new Claim(JwtRegisteredClaimNames.Sub,user.Email ?? throw new ArgumentNullException(nameof(user),"User's Email cannot be null")),
                new Claim(JwtRegisteredClaimNames.Email,user.Email),
                new Claim(JwtRegisteredClaimNames.Jti,Guid.NewGuid().ToString()),
                new Claim(JwtRegisteredClaimNames.Iat,DateTime.Now.ToUniversalTime().ToString()),

            ]);

            /*
                A token descriptor describes the properites and values to be in the token
            */
            var tokenDescriptor = new SecurityTokenDescriptor()
            {
                Subject = _claims,
                Expires = DateTime.UtcNow.Add(_config.ExpiryTimeFrame),
                SigningCredentials = new SigningCredentials(new SymmetricSecurityKey(key), SecurityAlgorithms.HmacSha256)

            };
            var token = jwtTokenHandler.CreateToken(tokenDescriptor);
            var jwtToken = jwtTokenHandler.WriteToken(token);


            //  creating a new refresh token
            var refreshToken = new RefreshToken()
            {
                JwtId = token.Id,
                Token = RandomStringGenerator(23), // Generate a refresh token
                ExpiryDate = DateTime.UtcNow.AddMonths(6),
                UserId = user.Id,
                IsRevoked = false,
                IsUsed = false,
                AddedDate = DateTime.UtcNow,

            };

            // adding the refresh token to the database
            await _context.RefreshTokens.AddAsync(refreshToken);
            await _context.SaveChangesAsync();



            return new AuthResults()
            {
                Token = jwtToken,
                RefreshToken = refreshToken.Token,
                Result = true
            };
        }

        private string RandomStringGenerator(int length)
        {
            var random = new Random();
            var chars = "ABCDEFGHIJKLMNOPQRSTUVWXYZ1234567890_abcdefghijklmnopqrstuvwxyz";
            return new string(
                Enumerable.Repeat(chars, length) // creates an array of of length (length) consisting of repeated value stored in variable(char); 
            .Select(s => s[random.Next(s.Length)]) // iterates over each element and selects an element of random index generated by random.Next
            .ToArray() // the above returns IEnumurable<chars> so using .ToArray it converts into array of chars
            ); // converts the array of chars to a strings
        }

        public async Task<AuthResults> ValidateAndGenerateToken(TokenRequestDto tokenRequest)
        {
            var JwtHandler = new JwtSecurityTokenHandler();
            try
            {

                //validateing the token if it is from our service or not
                _tokenValidationParameters.ValidateLifetime = false;
                var TokenInVerification = JwtHandler.ValidateToken(tokenRequest.Token, _tokenValidationParameters, out var validatedToken);
                if (validatedToken is JwtSecurityToken jwtSecurityToken)
                {
                    var results = jwtSecurityToken.Header.Alg.Equals(SecurityAlgorithms.HmacSha256, StringComparison.InvariantCultureIgnoreCase);
                    if (results == false)
                    {
                        return new AuthResults()
                        {
                            Errors = ["Invalid Token"],
                            Result = false
                        };
                    }
                    if (TokenInVerification != null && TokenInVerification.Claims.Any())
                    {
                        var _expClaim = TokenInVerification.Claims
                        .FirstOrDefault(
                            token => token.Type == JwtRegisteredClaimNames.Exp
                            );
                        if (_expClaim == null)
                        {
                            return new AuthResults()
                            {
                                Errors = ["token not valid"],
                                Result = false
                            };
                        }
                        var utcExpiryDate = long.Parse(_expClaim.Value);
                        var expiryDate = UnixTimeStampToDate(utcExpiryDate);
                        if (expiryDate > DateTime.Now)
                        {
                            return new AuthResults()
                            {
                                Errors = ["Exipred Token"],
                                Result = false
                            };
                        }

                        var _storedToken = await _context.RefreshTokens.FirstOrDefaultAsync(x => x.Token == tokenRequest.RefreshToken);
                        if (_storedToken is null || _storedToken.IsUsed || _storedToken.IsRevoked)
                        {
                            return new AuthResults()
                            {
                                Errors = ["token not valid"],
                                Result = false
                            };
                        }

                        var jti = TokenInVerification.Claims.FirstOrDefault(x => x.Type == JwtRegisteredClaimNames.Jti);
                        if(jti is null || jti.Value is null){
                            return new AuthResults()
                            {
                                Errors = ["token not valid"],
                                Result = false
                            };
                        }
                        if (_storedToken.JwtId != jti.Value)
                        {
                            return new AuthResults()
                            {
                                Errors = ["token not valid"],
                                Result = false
                            };
                        }
                        if (_storedToken.ExpiryDate < DateTime.UtcNow)
                        {
                            return new AuthResults()
                            {
                                Errors = ["Exipred Token"],
                                Result = false
                            };
                        }
                        // start generating a new token
                        _storedToken.IsUsed = true;
                        _context.RefreshTokens.Update(_storedToken);
                        await _context.SaveChangesAsync();
                        var dbUser = await _userManager.FindByIdAsync(_storedToken.UserId);
                        if (dbUser is null)
                        {
                            return new AuthResults()
                            {
                                Errors = ["Server Error"],
                                Result = false
                            };
                        }
                        return await GenerateJwtToken(dbUser);


                    }
                }
                return new AuthResults()
                {
                    Errors = ["Invalid Token"],
                    Result = false
                };


            }
            catch (System.Exception)
            {

                return new AuthResults()
                {
                    Errors = ["Server Error"],
                    Result = false
                };
            }
        }


        private DateTime UnixTimeStampToDate(long utcExpiryDate)
        {
            // 1970,1,1,0,0,0,0 is a standard unniex epoch ,starting point
            var dateTime = new DateTime(1970, 1, 1, 0, 0, 0, 0, DateTimeKind.Utc);
            var dateTimeVal = dateTime.AddSeconds(utcExpiryDate).ToUniversalTime();
            return dateTimeVal;
        }
    }
}